---
title: "Neural Networks: Data - Real and Simulated"
author: "John Thompson"
date: "2023-10-03"
layout: post
categories:
- neural networks
- Rcpp
- simulation
- real data
- experiments
output:
    html_document:
    keep_md: true
editor_options:
  chunk_output_type: console
---



<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>In this series of posts, I aim to develop a workflow for using neural networks in data analysis. So far, I have developed R code for fitting a neural network by gradient descent, converted that code into C for increased speed and discussed the workings of the gradient descent algorithm, stressing the importance of the expected loss.</p>
<p>This post considers the data that I will use to test aspects of the neural network (NN) workflow and concentrates mainly on simulation. The methods discussed require a few minor tweaks to my C Code that I describe in a brief appendix.</p>
</div>
<div id="the-advantages-of-simulation" class="section level1">
<h1>The advantages of simulation</h1>
<p>Simulated data enable experiments in which the true underlying model is known and the expected loss can be calculated. Here are just a few of the things that could be investigated using simulated data.</p>
<ul>
<li>aspects of the data
<ul>
<li>the impact of the size of the training set<br />
</li>
<li>the impact of the form of the underlying trend<br />
</li>
<li>the impact of the amount of error in the response<br />
</li>
<li>the impact of correlation between the predictors<br />
</li>
<li>the impact of outliers<br />
</li>
<li>the impact of measurement error in the predictors<br />
</li>
</ul></li>
<li>aspects of the model fitting algorithm
<ul>
<li>the impact of the model architecture<br />
</li>
<li>the impact of the choice of activation function<br />
</li>
<li>the impact of the choice of loss function<br />
</li>
<li>the impact of the starting values<br />
</li>
<li>the impact of regularization</li>
<li>the impact of the choice of stopping rule</li>
</ul></li>
</ul>
<p>My plan is to use these and other investigations to define a workflow for using NNs in a data analysis and then to test the best strategy on real data.</p>
</div>
<div id="performance-measures" class="section level1">
<h1>Performance measures</h1>
<p>Simulation experiments are usually comparative, for instance, the comparison of a workflow with and without regularization. Such experiments need performance measures that summarise the differences. As I mentioned in my last post, the performance of a specific model is best judged by its expected loss, which can be approximated using a second large dataset that is independent of the training data. One of the big advantages of simulation is that test data of any size can be produced.</p>
<p>When the aim is to identify a method of analysis that is applicable to a wide range of problems, the performance of the fitted models needs to be averaged over a range of scenarios and a range of training datasets.</p>
<p>The most frequently used performance measures are</p>
<ul>
<li>the training loss<br />
</li>
<li>the expected loss (approximated using a large test set)<br />
</li>
<li>the cross-validation loss<br />
</li>
<li>the time or number of iterations to convergence</li>
</ul>
<p>These measures need to be averaged over multiple sets of training data generated from the same underlying model with decisions based on the average performance, although the variance in performance may also be interesting. When one of the simulated datasets produces extreme performance, either good or bad, it is important to discover the causes of the unexpected result, as these might give a clue to ways in which the workflow could be improved.</p>
<p>Sometimes it is informative to calculate performance locally, that is to say over subsets of the training or test data. For example, a NN used for regression, might produce good predictions when the true response is small, but give unreliable predictions when the true response is large.</p>
</div>
<div id="neural-networks-for-simulation" class="section level1">
<h1>Neural Networks for Simulation</h1>
<p>One of the most difficult design considerations in a simulation study is the choice of the true underlying relationship between the inputs and the outputs. This needs to be complex enough to challenge the model, but not so complex that it is unrealistic. It is often said of simulation studies that whatever method you advocate, you can always find some structure that will show your choice of method in a good light. If you want to develop a good workflow, then it is important to establish that it works well across a wide range of scenarios.</p>
<p>Neural networks (NNs) are designed to create very flexible models, so if you want to simulate data with a wide variety of different relationships, why not use a NN?</p>
<div id="single-input-single-output" class="section level3">
<h3>Single input, single output</h3>
<p>Suppose that we were to take a basic NN, say (1, 10, 1), which is to say, a single predictor X, a single response, Y, and a single hidden layer with 10 nodes. The plots below show Y against X for randomly generated sets of biases and weights and a sigmoid activation function.</p>
<pre class="r"><code># The design
arch &lt;- c(1, 10, 1)
design &lt;- cprepare_nn(arch)

# sequence of values for the predictor
Xs &lt;- matrix(seq(0, 1, 0.02), ncol=1)

# create 9 different sets of weights &amp; biases
par(mfrow=c(3,3))  
for( s in 2670:2678) {
  set.seed(s)
  # random parameters
  design$bias   &lt;- runif(length(design$bias), -3, 3)
  design$weight &lt;- runif(length(design$weight), -10, 10) 
  # predicted response under the model
  Ys &lt;- cpredict_nn(Xs, design, actFun=c(1, 0))
  # plot of the relationship
  plot(Xs[, 1], Ys[,1], type=&quot;l&quot;, main=paste(&quot;seed=&quot;,s), ylab=&quot;Y&quot;, xlab=&quot;X&quot;)
}
mtext(&quot;Random Curves&quot;, side = 3, line = - 1.5, cex=1.5, outer = TRUE)</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-1-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(mfrow=c(1, 1)  )</code></pre>
<p>Training data can be generated by adding noise to the response. For clarity of presentation, the datasets plotted below have only 50 observations.</p>
<pre class="r"><code># random values for the predictor
set.seed(4678)
X &lt;- matrix(runif(50, 0, 1), ncol=1)

# create 9 different sets of weights &amp; biases
par(mfrow=c(3,3))  
for( s in 2670:2678) {
  set.seed(s)
  # random parameters
  design$bias   &lt;- runif(length(design$bias), -3, 3)
  design$weight &lt;- runif(length(design$weight), -10, 10) 
  # predicted response at the plotting points
  Ys &lt;- cpredict_nn(Xs, design, actFun=c(1, 0))
  # predicted response for the random predictors
  Y &lt;- cpredict_nn(X, design, actFun=c(1, 0))
  # add noise to the response
  Y[, 1] &lt;- Y[, 1] + rnorm(50, 0, 1) 
  # plot the training data
  plot(X[, 1], Y[,1], main=paste(&quot;seed=&quot;,s), pch=16, ylab=&quot;Y&quot;, xlab=&quot;X&quot;)
  lines(Xs[, 1], Ys[, 1])
}
mtext(&quot;Random Data&quot;, side = 3, line = - 1.5, cex=1.5, outer = TRUE)</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-2-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(mfrow=c(1, 1)  )</code></pre>
<p>Increasing the size of the noise would obviously make the underlying pattern harder to find.</p>
<p>For more complex underlying curves, just use a NN with more parameters. The following examples use random weights and biases in a (1, 8, 8, 1) NN.</p>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-3-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="multiple-inputs-single-output" class="section level3">
<h3>Multiple inputs, single output</h3>
<p>This method is not restricted to a single input, a (5, 6, 1) NN has 5 inputs and one response.</p>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-4-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>This simulation creates five independent uniform(0, 1) predictors that show no relationships in the plots. There is a relationship between the xâ€™s and the response y and, as no noise has been added, the relationship is a smooth high dimensional response surface, although it is impossible to see that from these marginal plots.</p>
<p>It might be more realistic to have predictors that are not independent, perhaps a (2, 6, 5) NN could be used to create five correlated predictors.</p>
<pre class="r"><code># The design
arch &lt;- c(2, 6, 5)
design &lt;- cprepare_nn(arch)
set.seed(3281)
# random values for the two generators
U &lt;- matrix(runif(100, 0, 1), ncol=2)
# random parameters
design$bias   &lt;- runif(length(design$bias), -3, 3)
design$weight &lt;- runif(length(design$weight), -10, 10) 
# create the predictors from the generators
X &lt;- cpredict_nn(U, design, actFun=c(1, 0))
colnames(X) &lt;- paste0(&quot;x&quot;, 1:5)
# matrix plot of predictors 
pairs( X, pch=16)</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Now a (5, 6, 1) NN adds the response</p>
<pre class="r"><code># The design
arch &lt;- c(5, 6, 1)
design &lt;- cprepare_nn(arch)
set.seed(3281)
# random parameters
design$bias   &lt;- runif(length(design$bias), -3, 3)
design$weight &lt;- runif(length(design$weight), -10, 10) 
# response  
Y &lt;- cpredict_nn(X, design, actFun=c(1, 0))
colnames(Y) &lt;- &quot;y&quot;
# matrix plot of predictors and response
pairs( cbind(X, Y), pch=16)</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-6-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Here is the matrix plot with noise added to the response</p>
<pre class="r"><code># add noise to the response
Y[, 1] &lt;- Y[, 1] + rnorm(50, 0, 1)
# matrix plot of predictors and response
pairs( cbind(X, Y), pch=16)</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>There are strong patterns between the Xâ€™s and a more obvious relationship with Y. The more generators, U, that are used when creating the predictors, the weaker will be the associations between the Xâ€™s.</p>
<p>I am sure that you are ahead of me in seeing that this simulation could have been created from a single run of a (2, 6, 5, 6, 1) neural network. Layer 3 would contain the predictors and layer 5 would contain the response. You would need to use an activation function such as the sigmoid for layers 2 and 4 and the identity function for layers 3 and 5, which is why I modified the way in which my C code specifies the activation functions (see the appendix).</p>
</div>
</div>
<div id="experiment-varying-the-noise-in-the-response" class="section level1">
<h1>Experiment: varying the noise in the response</h1>
<p>When (1, 10, 1) NNs with random parameters are used to create different response curves, seed 2673 produces an interesting shape, so I will use that as the basis for an investigation. The idea is to illustrate the method of investigation, not to come up with any startling discoveries.</p>
<p>My aim here is investigate the ability of a (1, 3, 1) NN to recover this curve when the amount of noise varies. The root mean square error (RMSE) will be used to measure performance.</p>
<p>The investigation uses one NN to simulate the data and another to analyse it, I refer to these as the <code>base_design</code> and the <code>analysis_design</code> respectively.</p>
<div id="the-basic-simulation" class="section level2">
<h2>The basic simulation</h2>
<p>First I will simulate some training data with N(0, 1) noise.</p>
<pre class="r"><code># The design
arch &lt;- c(1, 10, 1)
base_design &lt;- cprepare_nn(arch)
set.seed(2673)
base_design$bias &lt;- runif(length(base_design$bias), -3, 3)
base_design$weight &lt;- runif(length(base_design$weight), -10, 10)
# sequence of values for plotting
Xs &lt;- matrix(seq(0, 1, 0.02), ncol=1)
Ys &lt;- cpredict_nn(Xs, base_design, actFun=c(1, 0))
# random predictors n=100
set.seed(7865)
X &lt;- matrix(runif(100, 0, 1), ncol=1)
# random response with noise
err &lt;- rnorm(100, 0, 1)
Y &lt;- cpredict_nn(X, base_design, actFun=c(1, 0)) + err
# plot of the simulated data  
plot(X[, 1], Y[,1], pch=16, main=&quot;Simulated data&quot;, ylab=&quot;Y&quot;, xlab=&quot;X&quot;)
lines(Xs[, 1], Ys[, 1])</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>As expected the standard deviation of the errors is close to 1.0</p>
<pre class="r"><code>sd(err)</code></pre>
<pre><code>## [1] 1.006821</code></pre>
<p>A large set of test data (n=50,000) can be created from the same model.</p>
<pre class="r"><code># test dataset from the same base_design n=50000
set.seed(7865)
Xv &lt;- matrix(runif(50000, 0, 1), ncol=1)
Yv &lt;- cpredict_nn(Xv, base_design, actFun=c(1, 0)) + rnorm(50000, 0, 1)</code></pre>
<p>Now letâ€™s see how well we can recover the true relationship using a (1, 3, 1) NN run for 5,000 iterations.</p>
<pre class="r"><code># The analysis design
analysis_arch   &lt;- c(1, 3, 1)
analysis_design &lt;- cprepare_nn(analysis_arch)
# random starting values
set.seed(8808)
analysis_design$bias   &lt;- runif(length(analysis_design$bias), -3, 3)
analysis_design$weight &lt;- runif(length(analysis_design$weight), -10, 10)
# fit the NN by gradient descent
fit &lt;- cfit_nn(X, Y, analysis_design, eta=0.1, nIter=5000, trace=0, actFun=c(1, 0))
# predicted response under the analysis model
Yf &lt;- cpredict_nn(Xs, analysis_design, actFun=c(1, 0))
# plot of the results
plot(X[, 1], Y[,1], pch=16, main=&quot;Simulated data &amp; model fit&quot;, ylab=&quot;Y&quot;, xlab=&quot;X&quot;)
lines(Xs[, 1], Ys[, 1], lwd=2)
lines(Xs[, 1], Yf[, 1], col=&quot;blue&quot;, lwd=2)</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>The training RMSE is returned by <code>cfit_nn()</code> and test RMSE can be found directly from the test data</p>
<pre class="r"><code># training RMSE
sqrt(fit$lossHistory[5000])</code></pre>
<pre><code>## [1] 0.9970785</code></pre>
<pre class="r"><code># test (expected) RMSE
yhat &lt;- cpredict_nn(Xv, analysis_design, actFun=c(1, 0))
sqrt(mean((Yv[, 1] - yhat[, 1])^2))</code></pre>
<pre><code>## [1] 1.018505</code></pre>
<p>The RMSE is an estimate of the residual standard deviation, which we know from the design of the simulation ought to be about 1.0.</p>
<p>It is almost impossible to draw any conclusions from a single set of training data, we do not know if, by chance, the simulation generated training data with some unusual feature. Clearly, we need to repeat the simulation with different seeds. For ease of presentation, I will create nine simulated sets of training data so that they fit into a 3x3 grid.</p>
<pre class="r"><code># The analysis design
arch &lt;- c(1, 3, 1)
analysis_design &lt;- cprepare_nn(arch)
# space for saving the performance measures
rmse_train &lt;- rep(0, 9)
rmse_test &lt;- rep(0, 9)
# seeds for the data and the starting values
set.seed(2503)
data_seed &lt;- sample(1000:9999, size=9, replace=FALSE)
start_seed &lt;- sample(1000:9999, size=9, replace=FALSE)
# run 9 simulations
par(mfrow=c(3,3))  
for(i in 1:9) {
  # random set of training data
  set.seed(data_seed[i])
  X &lt;- matrix(runif(100, 0, 1), ncol=1)
  Y &lt;- cpredict_nn(X, base_design, actFun=c(1, 0)) + rnorm(100, 0, 1)
  # random starting values
  set.seed(start_seed[i])
  analysis_design$bias   &lt;- runif(length(analysis_design$bias), -3, 3)
  analysis_design$weight &lt;- runif(length(analysis_design$weight), -10, 10)
  # fit the analysis model
  fit &lt;- cfit_nn(X, Y, analysis_design, eta=0.1, nIter=5000, trace=0, actFun=c(1, 0))
  # collect performance measures
  rmse_train[i] &lt;- sqrt(fit$lossHistory[5000])
  yhat &lt;- cpredict_nn(Xv, analysis_design, actFun=c(1, 0))
  rmse_test[i] &lt;- sqrt(mean((Yv[, 1] - yhat[, 1])^2))
  # plot the data and fitted response
  Yf &lt;- cpredict_nn(Xs, analysis_design, actFun=c(1, 0))
  plot(X[, 1], Y[, 1], pch=16, ylim=c(-14, -9), xlim=c(0,1), xlab=&quot;X&quot;, ylab=&quot;Y&quot;)
  lines(Xs[, 1], Ys[, 1])
  lines(Xs[, 1], Yf[, 1], col=&quot;blue&quot;, lwd=2)
}
mtext(&quot;Curves fitted to nine random datasets&quot;, side = 3, line = - 1.5, 
      cex=1.5, outer = TRUE)</code></pre>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>par(mfrow=c(1,1))
# summarise the performance measured
summary(rmse_train)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.8914  0.9037  0.9417  0.9834  1.0174  1.2377</code></pre>
<pre class="r"><code>summary(rmse_test)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.019   1.027   1.036   1.074   1.060   1.336</code></pre>
<p>Runs 3 and 4 completely fail to find the shape. Perhaps, more iterations would improve the performance, 5,000 was an arbitrary choice on my part; or perhaps it is the starting values. As is usual, the test RMSE is larger than the training RMSE indicating a slightly worse fit, but the difference is small.</p>
<p>Here is a second analysis of the same 9 datasets, but with different starting values.</p>
<p><img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-14-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>A nice example of the importance of repeating the gradient descent algorithm with different starting values. This time the model finds the curve for dataset 3 without a problem, but fails for datasets 2, 4 and 9.</p>
<p>Here is an analysis of the same basic curve but with N(0, 2) noise in the response.
<img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>The underlying pattern is far harder to detect by eye and the analysis does well to recover it in four of the examples.</p>
</div>
<div id="the-experiment" class="section level2">
<h2>The experiment</h2>
<p>I continued the investigation of fitting a NN(1, 3, 1) to this pattern of data by</p>
<ul>
<li>increasing the number of datasets to 20<br />
</li>
<li>analysing each dataset 3 times from different starting values and taking the one with the lowest training loss<br />
</li>
<li>varying the standard deviation of the noise, sigma, to be from 0.5 to 3.0 in steps of 0.5<br />
</li>
<li>monitoring the training and test loss</li>
</ul>
<p>This requires 20 x 3 x 6 = 360 analyses. Here are the results, averaged over the 20 datasets</p>
<div id="tbldfzzulo" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#tbldfzzulo table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#tbldfzzulo thead, #tbldfzzulo tbody, #tbldfzzulo tfoot, #tbldfzzulo tr, #tbldfzzulo td, #tbldfzzulo th {
  border-style: none;
}

#tbldfzzulo p {
  margin: 0;
  padding: 0;
}

#tbldfzzulo .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#tbldfzzulo .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#tbldfzzulo .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#tbldfzzulo .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#tbldfzzulo .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#tbldfzzulo .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#tbldfzzulo .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#tbldfzzulo .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#tbldfzzulo .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#tbldfzzulo .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#tbldfzzulo .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#tbldfzzulo .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#tbldfzzulo .gt_spanner_row {
  border-bottom-style: hidden;
}

#tbldfzzulo .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#tbldfzzulo .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#tbldfzzulo .gt_from_md > :first-child {
  margin-top: 0;
}

#tbldfzzulo .gt_from_md > :last-child {
  margin-bottom: 0;
}

#tbldfzzulo .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#tbldfzzulo .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#tbldfzzulo .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#tbldfzzulo .gt_row_group_first td {
  border-top-width: 2px;
}

#tbldfzzulo .gt_row_group_first th {
  border-top-width: 2px;
}

#tbldfzzulo .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#tbldfzzulo .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#tbldfzzulo .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#tbldfzzulo .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#tbldfzzulo .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#tbldfzzulo .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#tbldfzzulo .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#tbldfzzulo .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#tbldfzzulo .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#tbldfzzulo .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#tbldfzzulo .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#tbldfzzulo .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#tbldfzzulo .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#tbldfzzulo .gt_left {
  text-align: left;
}

#tbldfzzulo .gt_center {
  text-align: center;
}

#tbldfzzulo .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#tbldfzzulo .gt_font_normal {
  font-weight: normal;
}

#tbldfzzulo .gt_font_bold {
  font-weight: bold;
}

#tbldfzzulo .gt_font_italic {
  font-style: italic;
}

#tbldfzzulo .gt_super {
  font-size: 65%;
}

#tbldfzzulo .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#tbldfzzulo .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#tbldfzzulo .gt_indent_1 {
  text-indent: 5px;
}

#tbldfzzulo .gt_indent_2 {
  text-indent: 10px;
}

#tbldfzzulo .gt_indent_3 {
  text-indent: 15px;
}

#tbldfzzulo .gt_indent_4 {
  text-indent: 20px;
}

#tbldfzzulo .gt_indent_5 {
  text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
<thead>
<tr class="gt_heading">
<td colspan="5" class="gt_heading gt_title gt_font_normal" style>
Investigation of the impact of increased noise
</td>
</tr>
<tr class="gt_heading">
<td colspan="5" class="gt_heading gt_subtitle gt_font_normal gt_bottom_border" style>
averaged over 20 datasets
</td>
</tr>
<tr class="gt_col_headings gt_spanner_row">
<th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="2" colspan="1" scope="col" id="Sigma">
Sigma
</th>
<th class="gt_center gt_columns_top_border gt_column_spanner_outer" rowspan="1" colspan="2" scope="colgroup" id="average RMSE">
<span class="gt_column_spanner">average RMSE</span>
</th>
<th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="2" colspan="1" scope="col" id="test-sigma">
test-sigma
</th>
<th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="2" colspan="1" scope="col" id="test/sigma">
test/sigma
</th>
</tr>
<tr class="gt_col_headings">
<th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="training">
training
</th>
<th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="test">
test
</th>
</tr>
</thead>
<tbody class="gt_table_body">
<tr>
<th id="stub_1_1" scope="row" class="gt_row gt_right gt_stub">
0.5
</th>
<td headers="stub_1_1 mtr" class="gt_row gt_right">
0.556
</td>
<td headers="stub_1_1 mte" class="gt_row gt_right">
0.570
</td>
<td headers="stub_1_1 r" class="gt_row gt_right">
0.070
</td>
<td headers="stub_1_1 v" class="gt_row gt_right">
1.139
</td>
</tr>
<tr>
<th id="stub_1_2" scope="row" class="gt_row gt_right gt_stub">
1.0
</th>
<td headers="stub_1_2 mtr" class="gt_row gt_right">
1.033
</td>
<td headers="stub_1_2 mte" class="gt_row gt_right">
1.056
</td>
<td headers="stub_1_2 r" class="gt_row gt_right">
0.056
</td>
<td headers="stub_1_2 v" class="gt_row gt_right">
1.056
</td>
</tr>
<tr>
<th id="stub_1_3" scope="row" class="gt_row gt_right gt_stub">
1.5
</th>
<td headers="stub_1_3 mtr" class="gt_row gt_right">
1.524
</td>
<td headers="stub_1_3 mte" class="gt_row gt_right">
1.557
</td>
<td headers="stub_1_3 r" class="gt_row gt_right">
0.057
</td>
<td headers="stub_1_3 v" class="gt_row gt_right">
1.038
</td>
</tr>
<tr>
<th id="stub_1_4" scope="row" class="gt_row gt_right gt_stub">
2.0
</th>
<td headers="stub_1_4 mtr" class="gt_row gt_right">
2.017
</td>
<td headers="stub_1_4 mte" class="gt_row gt_right">
2.061
</td>
<td headers="stub_1_4 r" class="gt_row gt_right">
0.061
</td>
<td headers="stub_1_4 v" class="gt_row gt_right">
1.030
</td>
</tr>
<tr>
<th id="stub_1_5" scope="row" class="gt_row gt_right gt_stub">
2.5
</th>
<td headers="stub_1_5 mtr" class="gt_row gt_right">
2.513
</td>
<td headers="stub_1_5 mte" class="gt_row gt_right">
2.568
</td>
<td headers="stub_1_5 r" class="gt_row gt_right">
0.068
</td>
<td headers="stub_1_5 v" class="gt_row gt_right">
1.027
</td>
</tr>
<tr>
<th id="stub_1_6" scope="row" class="gt_row gt_right gt_stub">
3.0
</th>
<td headers="stub_1_6 mtr" class="gt_row gt_right">
3.011
</td>
<td headers="stub_1_6 mte" class="gt_row gt_right">
3.077
</td>
<td headers="stub_1_6 r" class="gt_row gt_right">
0.077
</td>
<td headers="stub_1_6 v" class="gt_row gt_right">
1.026
</td>
</tr>
</tbody>
</table>
</div>
<p>As the noise (sigma) increases, so the average test RMSE comes closer to sigma on the ratio scale (test/sigma), but further away as a difference (test-sigma). I was expecting a clear deterioration in performance as the standard deviation of the noise increases, but this not evident. One reservation that I have is that these fits come from the gradient descent algorithm run for exactly 5,000 iterations. As yet, I have not discussed the issue of a stopping rule, but we know from my previous post that if the algorithm is run for too long, the performance on test data will deteriorate. Perhaps, 5,000 iterations is too many when sigma=0.5.</p>
<p>Despite the simplicity of this investigation, it raises many questions that test our understanding neural networks and gradient descent.</p>
<ul>
<li>was 20 datasets enough?<br />
</li>
<li>was 3 sets of starting values enough?<br />
</li>
<li>ratio or difference, which is better? why?<br />
</li>
<li>did the stopping rule have a distorting impact on the results?<br />
</li>
<li>what would happen with even larger (smaller) amounts of noise?<br />
</li>
<li>what about noise that is not Gaussian?<br />
</li>
<li>would the same pattern be evident with a different underlying curve?<br />
</li>
<li>are the results distorted by one or two datasets that are hard to fit?<br />
</li>
<li>would we get the same pattern from a (1, 4, 1) neural network? what about other architectures?<br />
</li>
<li>the data were generated by a NN(1, 10, 1), what would happen if that same architecture were used in the analysis?</li>
</ul>
</div>
<div id="a-simulation-with-5-predictors" class="section level2">
<h2>A simulation with 5 predictors</h2>
<p>In this simulation the data are generated from a (5, 6, 1) NN and analysed with a (5, 3, 1) NN. I have chosen to run 10,000 iterations to enable the gradient descent more time to search over the increased number of parameters.</p>
<p>Here is a single data set to help visualise the problem
<img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-17-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>The Xs are independent uniform(0, 1) and the relationship with N is based on the NN plus N(0, 1) noise in the response.</p>
<p>Here are the residual plots for 9 random datasets with the same underlying relationship
<img src="/post/neural_networks/05methods_nn_test_data_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.8417  1.0541  1.1566  1.3715  1.3620  2.4943</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.402   1.566   1.598   1.867   1.721   2.947</code></pre>
<p>The plots of residuals against fitted values show quite variable performance. Datasets 6 and 7 perform rather poorly. This can be seen in the training RMSEs that vary from 0.84 up to 2.49, when the ideal would be close to 1. Perhaps the algorithm needs more iterations, or maybe one set of starting values is insufficient. The test RMSE shows a similarly wide variation, but is always greater than 1.</p>
</div>
</div>
<div id="real-data" class="section level1">
<h1>Real Data</h1>
<p>The advantages of using simulated data are clear, but they always leave you wondering if the methods that work well in a simulation experiment will also work well on real data. For this reason, it is good practice to take any workflow that is developed on simulated data and test it on real data.</p>
<p>One good source of real data is kaggle (<a href="https://www.kaggle.com/datasets" class="uri">https://www.kaggle.com/datasets</a>). kaggle has a regular competition called <code>playground</code> in which they present smallish tabular datasets and invite people to try out their machine learning skills. These data are all based on real datasets, but the playground data are in fact simulated by deep learning to resemble the original data. In my experience the datasets are well-designed so as not to be too easy, but they always leave me wondering whether I am analysing the data, or the method that kaggle used in the simulation.</p>
<p>kaggle also offer a mass of real data some with prizes for the best solutions, but many others that are just there for interest. The problem is not the availability of data, but the difficulty of finding a dataset that is just right for your needs.</p>
<p>There is no point in listing the many other sources of real data, because there is already a Wikipedia page that does the job <a href="https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research" class="uri">https://en.wikipedia.org/wiki/List_of_datasets_for_machine-learning_research</a></p>
<p>Google even has a search engine specifically designed for finding datasets <a href="https://datasetsearch.research.google.com/" class="uri">https://datasetsearch.research.google.com/</a></p>
<p>If your interests are scientific then Nature has a useful webpage at <a href="https://www.nature.com/sdata/policies/repositories" class="uri">https://www.nature.com/sdata/policies/repositories</a> that lists relevant data repositories. The data in these repositories are often linked to scientific publications. I have found the Dryad repository (<a href="https://datadryad.org/search" class="uri">https://datadryad.org/search</a>) and the GEO repository (<a href="https://www.ncbi.nlm.nih.gov/geo/" class="uri">https://www.ncbi.nlm.nih.gov/geo/</a>) to be particularly useful.</p>
</div>
<div id="half-and-half" class="section level1">
<h1>Half and half</h1>
<p>When there is a particular real dataset or a particular real type of data that are of special interest, a good plan is to base the simulation study on those real data. Such simulations can be controlled by unsupervised neural networks as, I assume, kaggle does for its playground series, but such neural networks require quite a lot of development beyond what I have covered so far, so I will need to return to this approach at a later date.</p>
</div>
<div id="how-many-replicates" class="section level1">
<h1>How many replicates</h1>
<p>In my examples, I have chosen to run nine replicate datasets, because they plot neatly in a 3x3 grid. Generally you will need more than nine replicates.</p>
<p>The key to making the choice of the final number of replicates is to base it on a preliminary run with just a few replicates. Take the example with 5 predictors given above. The mean test RMSE was 1.9 and the standard deviation was about 0.5. This means that the standard error of the mean was about 0.5/sqrt(9) or 0.17 and the true average test RMSE is likely to be between 1.56 and 2.24 (two standard errors from the mean). This is a very wide range, which would make comparison with other methods very unreliable.</p>
<p>Suppose that you decided that you needed to know the true test RMSE to within 0.2 i.e.Â a standard error of 0.1. The formula, 0.5/sqrt(n)=0.1 implies that n=25, so we would need to run 25 replicate sets of data.</p>
<p>You could extend such back of the envelope calculations into a full analysis of power as you might when designing a clinical trial or a real world experiment. This is probably over the top. If you run insufficient replicates then it will be evident when you look at the results, in which case you just redesign the experiment and run it again. Simulation experiments are cheap, at least for small to moderate sized neural networks.</p>
</div>
<div id="conclusions" class="section level1">
<h1>Conclusions</h1>
<p>Neural networks with random weights and biases provide an excellent way of creating simulated datasets with a variety of underlying structures. In any experiment based on simulation from a NN, it is good practice to include one analysis based on the the same architecture as was used in the simulation, as this will form a baseline against which other models can be compared. However, good performance when you have the true model is of no real importance in itself, since real data are not generated by a NN and if they were, you would not know the underlying truth. Justifying the choice of network architecture for the analysis is one of the main jobs of a comprehensive workflow.</p>
<hr />
</div>
<div id="appendix-code-changes" class="section level1">
<h1>Appendix: Code Changes</h1>
<p>The C code used in this and my previous post can be found on my GitHub pages (<a href="https://github.com/thompson575/NeuralNetworks" class="uri">https://github.com/thompson575/NeuralNetworks</a>) as <code>cnnUpdate01.cpp</code>.</p>
<p>When simulating data from a NN it is useful to be able to switch off the activation for one of the hidden layers so that that layer can be used as the predictors while the output layer is the response. To enable this I modified the code so that the activations are given as a coded vector with one value for each layer and the different activations are built into a single C function. Here is a simplified version of the C function</p>
<pre class="r"><code>double cActivation(double z, int actFun = 0) {
  switch( actFun ) {
  case 1:
    return 1.0 / (1.0 + exp(-z));
  default:
    return z;
  }
}</code></pre>
<p>A data generating (2, 6, 5, 6, 1) neural network might have activation c(1, 0, 1, 0). The input layer does not need an activation function, so this coded vector says that the first hidden layer of 6 nodes uses the sigmoid, then next with 5 nodes uses the identity, then then sigmoid again and the output layer uses the identity. The other advantage of this rewriting of the code is that it will be easy to add other activation functions.</p>
<p>A new function <code>cNodalValues()</code> takes a set of weights and biases and a set of input values and returns the calculated values for every node. This extends <code>cpredict_nn()</code> that does the same thing but only returns the output layer. This function is useful for extracting an internal hidden layer when simulating.</p>
</div>
